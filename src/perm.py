# vim: ts=4 sw=0 sts=-1 et ai tw=80

"""
Permutation class
"""

import random, itertools

from operator import eq
from functools import lru_cache

# TODO: write dummy tests

# TODO: write this myself so there's no undefined behaviour
@lru_cache()
def Perm(n):
    class PermSn:
        """
        An object representing a permutation, which can be composed with other
        permutations. This implementation is agnostic to where its elements
        live, so long as they can be put in a dictionary.

        Permutation objects should be treated as immutable. New permutations can
        be obtained by calling methods like inverse() or composing existing
        permutations, which can be achieved by using the overloaded * operator.

        If you instantiate via __init__, this class assumes that you're a
        grown-up and you've given it a mapping that is a bijection. If you can't
        be sure, feel free to check with .is_permutation().
        """
        # I know what I'm doing:
        # pylint: disable=dangerous-default-value
        def __init__(self, mapping=range(n)):
            """
            Create a permutation directly by providing a dictionary map. Given no
            argument, returns an identity permutation.
            """
            self.mapping = mapping

        @classmethod
        def from_cycle(cls, cycle):
            """
            Instantiate a permutation from an iterable, which represents a cycle of
            elements, in the standard sense: if the list
            l = [l[0], l[1], ..., l[n - 1]] is passed, then
            l[i]     -> l[i + 1] where 0 <= i <= n - 2, and
            l[n - 1] -> l[0].

            If the iterable you pass contains repeated elements, you're not
            guaranteed to get a valid permutation (see __init__ documentation for
            next steps). However, if the iterable you pass is a number of copies of
            some smaller sequence, the cycle will be just the cycle generated by
            that smaller sequence (eg [1, 2, 1, 2, 1, 2] results in the
            transposition (1 2)).

            This behaviour is useful to specify as it means that for instance
            Perm.from_cycle([1, 1]) is the identity permutation, which can be a
            useful natural extension of cycle notation in certain edge cases in
            certain applications of permutations (for instance, ciphers).
            """
            mapping = list(range(n))
            cycle_iter = iter(cycle)
            try:
                elem = first = prev = next(cycle_iter)
            except StopIteration:
                return cls()
            for elem in cycle_iter:
                # order of evaluation is important here - the prev in
                # mapping[prev] is pre-assignment
                mapping[prev] = prev = elem
            mapping[elem] = first
            return cls(mapping)

        @classmethod
        def random(cls, domain):
            """
            Generate a pseudorandom permutation
            """
            outputs = list(range(n))
            random.shuffle(outputs)
            return cls(outputs)

        def is_permutation(self):
            """
            Simple method that checks if this is a permutation. This method should
            be robust as keys in the given mapping are supposed to be distinct.
            """
            # so inspiring
            self_image = set(self.mapping)
            return (len(self.mapping) == n and
                    all(i in self_image for i in range(n)))

        # def apply_mapping(self, mapping):
        #     """
        #     Return an identical permutation on a different set

        #     Using mapping to find which elements go to which
        #     """
        #     return type(self)({mapping[key]:mapping[value] for key, value in \
        #                     self.mapping.items()})

        def cycle_type(self):
            return sorted(map(len,
                              self.disjoint_cycle_decomposition_unstable()))

        def conjugate(self, g):
            return self.inverse() * g * self

        def disjoint_cycle_decomposition_unstable(self):
            """
            Get a list of lists which is the disjoint cycle decomposition. _DON'T_
            include 1-cycles, so that more can be inferred about cycle types across
            different domains from this decomposition.
            """
            # use a set for amortised O(1) lookup.
            remaining = set(self.mapping)
            decomposition = []
            while remaining:
                a = remaining.pop()
                cycle = [a]
                b = self.mapping[a]
                # this could of course be done beautifully with the walrus operator,
                # but I'm trying to keep my Ubuntu-using fans happy
                while b != a:
                    remaining.remove(b)
                    cycle.append(b)
                    b = self.mapping[b]
                if len(cycle) > 1:
                    decomposition.append(cycle)
            return decomposition

        def disjoint_cycle_decomposition_stable(self, key=lambda x: x):
            """
            A consistently presented disjoint cycle decomposition:

            Because everything here is stored in hash maps, it's very
            hard to guarantee any particular ordering in the disjoint cycle
            decomposition. Therefore I'm arbitrarily ordering by length, and then by
            smallest element (making the bold assumption that the elements can be
            ordered, which is usually fine with strings or integers), and writing
            each cycle with smallest element first.

            If your elements don't overload the inequality operators but you can
            think of some way to order them you can pass a key (which is passed to
            min). (see also functools.cmp_to_key)

            There is a certain associated overhead with this regularisation. If you
            just want raw cycles and don't care about making them pretty, use
            disjoint_cycle_decomposition_unstable.
            """
            decomposition = self.disjoint_cycle_decomposition_unstable()
            for cycle in decomposition:
                min_index = min(((i, ind) for ind, i in enumerate(cycle)),
                                key=key)[1]
                # I'm not sure if this is faster than slicing or not, but I
                # marginally prefer the feeling of not building intermediate lists.
                cycle[:] = [cycle[(min_index + i) % len(cycle)]
                        for i in range(len(cycle))]
            decomposition.sort(key=lambda cycle: key(cycle[0]))
            decomposition.sort(key=len)
            return decomposition

        def inverse(self):
            """
            Compute the inverse of a permutation, assuming self is actually a
            permutation.
            """
            inv_map = [None] * n
            for i in range(n):
                inv_map[self.mapping[i]] = i
            return type(self)(inv_map)

        def __str__(self):
            """
            Convert to disjoint cycle decomposition string
            """
            dcd = self.disjoint_cycle_decomposition_stable()
            if not dcd:
                return "Id"
            return "".join("({})".format(" ".join(map(str, cycle))) for cycle in
                    dcd)

        def __repr__(self):
            """
            Show the underlying dictionary object
            """
            return "Perm({})({})".format(n, self.mapping)

        def table_format(self):
            """
            Format permutation as a table
            """
            kv_pairs = self.mapping.items()
            if not kv_pairs:
                return "Id\n"
            keys, values = zip(*kv_pairs)
            kv_lengths = [max(len(str(i)) for i in kv) for kv in kv_pairs]
            return "{}\n{}".format(
                    " ".join(str(k).rjust(l) for k, l in zip(keys, kv_lengths)),
                    " ".join(str(v).rjust(l) for v, l in zip(values, kv_lengths)))

        def __getitem__(self, item):
            """
            (Use lookup syntax to apply the permutation to an element.

            Uses the convention that an unknown item is mapped to itself.)

            Usage of this method is discouraged in this application as it
            results in unnecessary extra namespace lookups. Directly do
            p.mapping[x].
            """
            raise ValueError("Please use Perm.mapping[...] instead.")
            return self.mapping.get(item, item)

        def __mul__(self, other):
            """
            Compose permutation with another.
            """
            return type(self)(tuple(self.mapping[other.mapping[i]] for i in range(n)))

        def __pow__(self, n):
            """
            Exponent of a permutation, in the standard group-theoretic sense.
            Probably it's O(k * log(n))-ish where k is the size of the domain, and n
            is the exponent, as it uses exponentiation by squaring.

            Possibly it's worth thinking about the asymptotic improvement brought by
            calculating the order of the permutation and taking n mod ord(g) (in
            fact asymptotically the time is then independent of n) but this is
            probably too theoretical to be useful.

            Supports negative exponents in the standard inverse sense.
            """
            if n < 0:
                return self.inverse() ** (-n)
            # Some hardcoded cases to avoid faffing around too much in the leaves of
            # the tree (and lets me write ** 2 in the recursive step, so the
            # auxiliary variable gets brushed under the recursion)
            if n == 0:
                return type(self)({})
            if n == 1:
                return self
            if n == 2:
                return self * self
            exp_by_sqr = (self ** (n // 2)) ** 2
            if n & 1:
                return self * exp_by_sqr
            return exp_by_sqr

        def __eq__(self, other):
            """
            Test for equality: all items map to the same thing.
            """
            return all(map(eq, self.mapping, other.mapping))

        def __hash__(self):
            """
            Nice quick-ish hash function
            """
            # tfw this isn't even faster :(
            # return hash(sum(j * n ** i for i, j in enumerate(self.mapping)))
            return hash(tuple(self.mapping))

        def order(self):
            """
            Compute the order of an element by multiplying it by itself
            """
            order = 1
            current = self
            while current != type(self)():
                current *= self
                order += 1
            return order
    return PermSn

def canonical_of_cycle_type(n, cycle_type):
    x = Perm(n)()
    i = 0
    for l in cycle_type:
        x *= Perm(n).from_cycle(range(i, i+l))
        i += l
    return x

def _conjugacy_class(n, values, cycle_type):
    if cycle_type == []:
        yield Perm(n)()
        return
    ct = cycle_type[0]
    for choice in itertools.combinations(values, ct):
        for g in map(Perm(n).from_cycle, itertools.permutations(choice)):
            for h in _conjugacy_class(n,
                    [v for v in values if v not in choice], cycle_type[1:]):
                yield g * h

def conjugacy_class(n, cycle_type):
    """
    Return set of all permutations of a given cycle type

    This is completely the wrong way to do it :D
    """
    return set(_conjugacy_class(n, list(range(n)), cycle_type))

